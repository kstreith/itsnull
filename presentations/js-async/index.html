<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>JS Async Patterns</title>
    
   <script type="text/javascript">
        var appInsights=window.appInsights||function(config){
            function r(config){t[config]=function(){var i=arguments;t.queue.push(function(){t[config].apply(t,i)})}}var t={config:config},u=document,e=window,o="script",s=u.createElement(o),i,f;for(s.src=config.url||"//az416426.vo.msecnd.net/scripts/a/ai.0.js",u.getElementsByTagName(o)[0].parentNode.appendChild(s),t.cookie=u.cookie,t.queue=[],i=["Event","Exception","Metric","PageView","Trace"];i.length;)r("track"+i.pop());return r("setAuthenticatedUserContext"),r("clearAuthenticatedUserContext"),config.disableExceptionTracking||(i="onerror",r("_"+i),f=e[i],e[i]=function(config,r,u,e,o){var s=f&&f(config,r,u,e,o);return s!==!0&&t["_"+i](config,r,u,e,o),s}),t
        }({
            instrumentationKey:"7835d8bd-cc2d-4cd1-ace6-04799eba844f"
        });
        
        window.appInsights=appInsights;
        appInsights.trackPageView();
    </script>
    
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/beige.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<meta name="description" content="JS Async Patterns">
		<meta name="author" content="Kip Streithorst">
    <style>
      ul.code { width: 100%; }
    </style>
		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
        <section>
          <h3>Javascript Async Patterns</h3>
          <h4>October 2016</h4>
          <h4>Follow along at:</h4>
          <p><a href="http://itsnull.com/">http://itsnull.com/</a></p>
          <p><a href="http://itsnull.com/presentations/js-async/">http://itsnull.com/presentations/js-async/</a></p>
          <p>
          <small>Created by <a href="http://itsnull.com">Kip Streithorst</a> / <a href="http://twitter.com/itsnull">@itsnull</a></small>
          </p>
        </section>
        <section>
          <h3>Overview</h3>
          <ul>
            <li>Sync vs. Async</li>
            <li>Fixes for async</li>
            <li>Demos</li>
            <li>Gotchas</li>
            <li>Looking forward</li>
          </ul>
        </section>
        <section>
          <h3>Our API</h3>
          <ul>
            <li>getNearbyStores(zipCode) -> list of ids</li>
            <li>getStoreDetails(storeId) -> details of store</li>
            <li>Both functions make call to server</li>
          </ul>
        </section>
        <section>
          <h3>Using our API - Ideally</h3>
          <ul class="code">
            <li>How we'd like to use:
              <pre><code class="js">function getClosestStore(zipCode) {
  var storeIds = getNearbyStores(zipCode);
  if (storeIds.length) {
    return getStoreDetails(storeIds[0]);
  }
  return null;
}
              </code></pre>
            </li>
          </ul>
        </section>
        <section>
          <h3>Why can't I do that in browser?</h3>
          <ul>
            <li>Each browser tab has a single UI thread</li>
            <li>That thread is shared between browser and your code</li>
            <li>So, if getNearbyStores took 5 seconds, UI thread would be blocked entire time</li>
            <li>So, browser vendors never added synchronous apis, only async apis</li>
            <li>Pass a callback to browser, when IO is complete, browser will call your callback</li>
          </ul>
        </section>        
        <section>
          <h3>Using our API - Reality</h3>
          <ul class="code">
            <li>Real example, using AJAX which is async:
              <pre><code class="js">function getClosestStore(zipCode, successCallback, failureCallback) {
  getNearbyStores(zipCode, function (storeIds) {
    if (storeIds.length) {
      getStoreDetails(storeIds[0], function (storeDetails) {
        successCallback(storeDetails);
      }, failureCallback);
    } else {
      successCallback(null);
    }    
  }, failureCallback);
}
              </code></pre>
            </li>
          </ul>
        </section>
        <section>
          <h3>Callbacks - PROS</h3>
          <ul>
            <li>Long history of usage</li>
            <li>Especially for events: click, keypress</li>
            <li>Well understood, simple for browsers to implement.</li>
          </ul>
        </section>               
        <section>
          <h3>Callbacks - CONS</h3>
          <ul class="code">
            <li>Inverts the function weirdly:
              <pre><code class="js">              
              var retData = performOperation();
              //... code that comes after
              //becomes
              performOperation(function (retData) {
                //.. code that comes after
              })
              </code></pre>
            </li>
            <li>Are unweidly when chained, wasn't a problem for event handlers, but now every IO operation causes another level of nesting.</li>
            <li>Much harder to read the control flow</li>
          </ul>
        </section>
        <section>
          <h3>Thought experiment time</h3>
          <ul>
            <li>Let's work through some thought experiments</li>
            <li>Goal is to improve flow and readability</li>
            <li>We will "invent" our own concepts</li>
            <li>Similiarity to any real or existing concepts is just that for now</li> 
          </ul>
        </section>
        <section>
          <h3>Use a smart object</h3>
          <ul>
            <li>What if we returned something that told us when the operation was complete?</li>
            <li>Let's call it Future</li>
            <li>Has 3 states: Start, Resolved, Rejected</li>
            <li>Has .resolve, .reject to move object into one of the two final states</li>
            <li>Has a .done function - done(successCallback)</li>
            <li>Has a .fail function - fail(failureCallback)</li>
            <li>Now, our function returns something instead of taking an callback argument</li>
          </ul>
        </section>
        <section>
          <h3>Future - state flow</h3>
          <img src="images/promise.svg" style="background-color: white;" />
        </section>
        <section>
          <h3>getClosestStore - Future</h3>
          <ul class="code">
            <li>Implement with future:
              <pre><code class="js">function getClosestStore(zipCode) {
  var retValue = new Future();
  getNearbyStores(zipCode).done(function (storeIds) {
    if (storeIds.length) {
      getStoreDetails(storeIds[0]).done(function (storeDetails) {
        retValue.resolve(storeDetails);
      }).fail(retValue.reject);
    } else {
      retValue.resolve(null);
    }    
  }).fail(retValue.reject);
  return retValue;
}
              </code></pre>
            </li>
          </ul>
        </section>
        <section>
          <h3>So?</h3>
          <ul>
            <li>PRO: Functions now return values</li>
            <li>PRO: Functions are only passed their arguments, not extra callbacks</li>
            <li>CON: Had to manually create our return value, e.g. Future</li>
            <li>CON: Had to manually resolve, reject it</li>
            <li>Did you notice? If something else rejects, we will likely reject</li>
            <li>If something else resolves, we will likely resolve as well</li>
          </ul>
        </section>        
        <section>
          <h3>Add chaining</h3>
          <ul>
            <li>Let's code that default logic into a new function</li>
            <li>.then(successCallback, failureCallback)</li>
            <li>The .then always returns a new Future, call it X</li>
            <li>If either callback returns a value, X resolves with that value</li>
            <li>If either callback has an exception, X rejects with that exception</li>
          </ul>
        </section>        
        <section>
          <h3>getClosestStore - Future w/ Chaining</h3>
          <ul class="code">
            <li>Implement with future w/ chaining:
              <pre><code class="js">function getClosestStore(zipCode) {  
  return getNearbyStores(zipCode).then(function (storeIds) {
    if (storeIds.length) {
      return getStoreDetails(storeIds[0]);
    }
    return null;
  });
}
              </code></pre>
            </li>
          </ul>
        </section>
        <section>
          <h3>Good enough?</h3>
          <ul>
            <li>Pretty close to our ideal</li>
            <li>No direct references to future, just the .then method</li>
            <li>Functions always return values, not passed callbacks</li>
            <li>One inconvenience, have to put code that uses the result into a callback</li>            
          </ul>
        </section>        
        <section>
          <h3>Can language help?</h3>
          <ul>
            <li>Maybe, the language could help?</li>
            <li>C# has async/await keywords, might those help?
              <pre><code class="js" class="code">var initialData = await getInitialData();
var result = await parseData(initialData);
printResult(result);
</code></pre>
</li>
            <li>The code that needs initialData result is put into a callback automatically by language, that's what await keyword does.</li>
          </ul>
        </section>         
        <section>
          <h3>getClosestStore - async/await</h3>
          <ul class="code">
            <li>Implement with async/await:
              <pre><code class="js">
function async getClosestStore(zipCode) {  
  var storeList = await getNearbyStores(zipCode);
  if (storeList.length) {
    return await getStoreDetails(storeList[0]);
  }
  return null;
}
              </code></pre>
            </li>
          </ul>
        </section>
        <section>
          <h3>Full circle</h3>
          <ul class="code">
            <li>Our ideal
              <pre><code class="js">
function getClosestStore(zipCode) {  
  var storeList = getNearbyStores(zipCode);
  if (storeList.length) {
    return getStoreDetails(storeList[0]);
  }
  return null;
}
              </code></pre>
            </li>
            <li>What we have now
              <pre><code class="js">
function async getClosestStore(zipCode) {  
  var storeList = await getNearbyStores(zipCode);
  if (storeList.length) {
    return await getStoreDetails(storeList[0]);
  }
  return null;
}
              </code></pre>
            </li>
          </ul>
        </section>
        <section>
          <h3>Nice, now what?</h3>
          <ul>
            <li>We just covered the history of solutions</li>
            <li>Demo async/await running in browsers</li>
            <li>Talk gotchas</li>
          </ul>
        </section>
        <section>
          <h3>Promise philosophy</h3>
          <ul>
            <li>Functions either: <strong>return a single value</strong> or <strong>throw an exception, e.g. Error subclass</strong></li>
            <li>Promises either: <strong>resolve with a single value</strong> or <strong>reject with an exception, e.g. Error subclass</strong></li>
            <li>So, when an async function returns a promise it is effectively doing the same thing a synchronous function does</li>
            <li>This is the appropriate mental model</li>
            <li>Also what async/await syntax depends upon</li>
          <ul>
        </section>
        <section>
          <h3>Exceptions and Promises</h3>
          <ul>
            <li><pre><code class="js">getClosestStore(12121).then(function (storeDetails) {
  if (store.open) { //has an exception?         
    //do stuff
  }
});</code></pre>
            </li>
            <li>.then returns a Promise, since callback has an exception, returned Promise is rejected</li>
            <li>I don't have an additional .then or a .catch</li>
            <li>Our mental model says that is an unhandled exception</li>
          </ul>
        </section>                
        <section>
          <h3>Async/Await Demo</h3>
          <ul>
            <li>Chrome Canary (e.g. v55) supports async/await already</li>
            <li>MS Edge supports behind experimental flag, since Sept. 2015</li>
            <li>Or transpile w/ BabelJS and add some polyfills</li>
            <li>Or coming in Typescript 2.1 (November 2016)</li>
          </ul>
        </section>                
        <section>
          <h3>Spec History</h3>
          <ul>
            <li>Initial Promise/A spec (2010)</li>
            <li>JQuery team implemented <strong>incorrectly</strong> (2011)</li>
            <li>New <a href="https://promisesaplus.com/">Promise/A+ spec</a> (2012), only describes .then method</li>            
            <li>Javascript Language - ES 2015 (e.g ES 6) adds Promises/A+</li>
            <li>Javascript Language documents constructor, .catch method</li>
            <li>Promise documentation on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">MDN</a></li>
            <li>Async/Await scheduled for next version of JS language <a href="https://github.com/tc39/proposals/blob/master/finished-proposals.md">ES 2017</a></li>
          </ul>
        </section>
        <section>
          <h3>How to use AJAX</h3>
          <ul>
            <li>Use fetch provided by browser</li>
            <li>Use your framework's method, must return Promises/A+ compatible</li>
            <li>Angular 1.x, $http</li>
            <li>Angular 2.x, http service but then need to call .toPromise()</li>
            <li>Don't use JQuery $.ajax, <strong>NOT Promises/A+ compatible</strong></li>
          </ul>
        </section>
        <section>
          <h3>Fetch</h3>
          <ul class="code">
            <li><a href="https://fetch.spec.whatwg.org/">New cross browser standard</a></li>
            <li>Simple function, similiar to $.ajax, $http.get, returns Promise/A+</li>
            <li><pre><code class="js">fetch('/api/users').then(function (response) {
  //processing
});
fetch('/api/users', {method: 'POST', body: new FormData(form)});
</code></pre></li>
            <li>Supported by latest browsers: Edge, Firefox, Chrome, Opera, Android</li>
            <li><a href="https://github.com/github/fetch">Polyfill</a> for older browsers, may also require a Promise polyfill as well</li>
          </ul>
        </section>                          
        <section>
          <h3>Warning - Be wary of JQuery</h3>
          <ul class="code">
            <li>$.Deferred has a .then method, doesn't implement Promises/A+</li>
            <li>$.ajax returns $.Deferred</li>
            <li><strong>Not interoperable</strong> with async/await or other libraries</li>
            <li>Finally fixed in JQuery 3.0 (June 2016)</li>
          </ul>
        </section>
        <section>
          <h3>Warning - No more cancellation</h3>
          <ul class="code">
            <li>Promises don't support cancellation</li>
            <li>Cancellation is highly useful when dealing with multiple in-flight requests where UI only cares about latest response</li>
            <li>Have a search page, user starts search, changes search, starts another search</li>
            <li>Search results make come back out-of-order</li>
            <li>Fix: Pass ordering key to server, it passes it back to client, ignore old responses</li>
            <li>Fix: Cancel prior unfinished request before starting a new request</li>
          </ul>
        </section>                           
        <section>
          <h3>Warning - No more cancellation, cont.</h3>
          <ul class="code">
            <li>XMLHttpRequest supports cancellation</li>
            <li>$.ajax supports cancellation</li>
            <li>Promises don't support cancellation</li>
            <li>Fetch doesn't support cancellation</li>
            <li>Browser vendors are brainstorming possible solutions</li>
          </ul>
        </section>
        <section>
          <h3>Warning - Uncaught rejections</h3>
          <ul class="code">
            <li>Remember exception in callback turns into rejection from Promise</li>
            <li>Need a .then or .catch to handle</li>
            <li>If you don't, it's an uncaught rejection</li>
            <li>All browsers (except Chrome), <strong>silently fail, no message or ability to find it</strong></li>
            <li>Makes it much harder to find bugs</li>
            <li>Bluebird.js provides a solution</li>
          </ul>
        </section>
        <section>
          <h3>Bluebird.js features</h3>
          <ul>
            <li>Will report errors to console for uncaught rejections in all browsers, even in Chrome</li>
            <li>Polyfills Promises for older browsers</li>
            <li>Encourages proper promise usage, e.g. reports error if rejecting with something other than an exception</li>
            <li>Debugging across an async jump can be difficult, latest dev tools in browsers fix this</li>
            <li>Bluebird provides long stack traces in older browsers that don't have latest dev tool features</li>
            <li>Provides a number of additional helpful methods</li>
          </ul>
        </section>
        <section>
          <h3>Promises</h3>
          <ul>
            <li>Poylfill: <a href="https://github.com/stefanpenner/es6-promise">https://github.com/stefanpenner/es6-promise</a></li>
            <li>Libraries provide polyfill plus more</li>
            <li><a href="http://bluebirdjs.com/">Bluebird.js</a>, <a href="https://github.com/tildeio/rsvp.js/">RSVP.js</a>, <a href="https://github.com/cujojs/when">When.js</a></li>                        
          </ul>
        </section>                                                                 
        <section>
          <h3>Beyond Promises</h3>
          <ul>
            <li>Promises handle a specific use case for async</li>
            <li>var result = doSomething();</li>
            <li>Great for AJAX, File I/O and delays, e.g. wait 5 seconds</li>
            <li>But browsers have two other async operations</li>
            <li>Events: click, keypress, mousemove</li>
            <li>Timers: fire every 10 seconds</li>
          </ul>
        </section>
        <section>
          <h3>Beyond Promises, cont.</h3>
          <ul>
            <li>A click can happen 0-n times</li>
            <li>It's kind of like a list, or maybe a infinite range, or wait a stream of events</li>
            <li>For C# devs, IEnumerable&lt;ClickEvent&gt;??</li>
            <li>But it's push not pull, e.g. the user pushes the event to us, we can't demand the next click</li>            
            <li>There is a pattern for this, Observable, e.g. subscribe</li>
            <li>What if we treat streams as first-class objects and provide functions to filter them, combine then, e.g. same as we do lists</li>
          </ul>
        </section>                
        <section>
          <h3>Beyond Promises, cont.</h3>
          <ul>
            <li>There is a <a href="https://tc39.github.io/proposal-observable/">Stage 1 Draft</a> for next version of JS language</li>
            <li>RxJs is a javascript library that implements parts of this proposal</li>
            <li>Angular 2.x returns RxJs Observable from http service, can still get promise using .toPromise method</li>
            <li>Spec is still early, may not make it into JS. Browsers may not support</li>
            <li>Only one implementation currently</li>
            <li>Promises, async/await fix most common issue: nested callbacks</li>
          </ul>
        </section>                
        <section>
          <h3>Thanks, Any Questions?</h3>
          <ul>
            <li>Kip Streithorst</li>
            <li>Twitter: <a target="_blank" href="http://twitter.com/itsnull">@itsnull</a></li>
            <li>Blog: <a target="_blank" href="http://itsnull.com/">http://itsnull.com/</a></li>
            <li>Presentation: <a target="_blank" href="http://itsnull.com/presentations/js-async/">http://itsnull.com/presentations/js-async/</a>
          </ul>
        </section>


        <!-- 
        <section>
          <h3>Wrap $.ajax into Promise</h3>
          <ul class="code">
            <li>Convert $.Deferred into Promise
              <pre><code class="js">function wrapAjax(settings) {
  return new Promise(function (resolve, reject) {
    $.ajax(settings).then(function (data, textStatus, jqXHR) {
      resolve({data: data, textStatus: textStatus, jqXHR: jqXHR});
    }, function (jqXHR, textStatus, errorThrown) {
      var e = new Error(textStatus);
      e.jqXHR = jqXHR;
      e.textStatus = textStatus;
      e.errorThrown = errorThrown;
      reject(e);
    });
  });
}            </code></pre></li>
          </ul>
        </section>
        <section>
          <h3>Wrap $.ajax into Promise w/ abort method</h3>
          <ul class="code">
            <li>Convert $.Deferred into Promise, add abort          
              <pre><code class="js">function wrapAjax(settings) {
  var dfd = $.ajax(settings);
  var p = new Promise(function (resolve, reject) {
    dfd.then(function (data, textStatus, jqXHR) {
      resolve({data: data, textStatus: textStatus, jqXHR: jqXHR});
    }, function (jqXHR, textStatus, errorThrown) {
      var e = new Error(textStatus);
      e.jqXHR = jqXHR;
      e.textStatus = textStatus;
      e.errorThrown = errorThrown;
      reject(e);
    });
  });
  p.abort = dfd.abort.bind(dfd); //this is a monkey-patch, could overwrite browser provided abort if one
  return p;
}            </code></pre></li>
          </ul>
        </section>  -->      
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
    
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-46954011-1', 'auto');
  ga('send', 'pageview');

</script>
    
	</body>
</html>
