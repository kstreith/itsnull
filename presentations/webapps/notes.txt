Original vs Modern
----------
Original is simpler model
Original is thin client, defers everything interesting to server
Modern is thick client
Modern provides rich applications
Modern not restricted to clicks to get data
Modern not restricted to updating whole page at a time
what are people building? Original? Modern? a mix? why?
Original - code executed on your server, you know the hardware, exceptions happen, you can capture them?
Modern - code executed in user's browser, which browser? what hardware? exceptions happen, do you know about them?
Original - easier for client to deal with, doesn't need a javascript VM, web scraping, search engine indexing, screen readers
Modern - Very similar to mobile application, step 1 is akin to installing your app, step 2 is app running, discuss e-mail app
Modern - Can talk to server whenever you want, auto-save every X minutes/seconds.
Modern - Doesn't require a back-end at all, see this presentation.
Modern - Updates can be pushed to all connected clients, e.g. chat, twitter (websockets)
Modern - App can be more responsive, only the parts required need to update & redraw, may not need server (e.g. client-side sorting)
Modern - Don't need a page for everything, i.e. add/edit/update, can have dialogs or inline edits.
Modern -Can be made to work offline and then talk to server when it's available (HTML5 local storage, service workers)
Modern - Choices used to be back-end specific, no longer, front-end choices can be mixed with back-end choices.
Modern - Not just ASP.NET datepickers, can use any front-end datepicker, not just ASP.NET grids, can you use any front-end grid. Much wider choice.

Developer Workflow
------------------
Front-end/back-end teams can be separated, run independently.
Back-end used to be one big script file, but now we use tools/frameworks to tame that (MVC, OOP, etc.)
Front-end doesn't need to be one big JS file, can also use tools/frameworks to tame that.
Unit testing can be done in browser's javascript vm.
With modern browsers, e.g. developer tools, you can prototype in the browser

Modern - Couple or De-couple
------------------------
Validations, Models - are they duplicated? why? why not?
Is back-end API independent of front-end? only for that front-end?
Do you use the same technology stack for both front-end/back-end?
Do you build assuming the front-end will be replaced in 5 years? Do you want that change having effects on vetted back-end?

Complexity
----------
When user clicked submit button before, browser became locked. Not now, user can still type away. Disable controls, use modals.
Before user didn't get page until all data was in the page, not now. Now, they have a page with no data in it. Spinners to the rescue.
Network may fail intermittently, how to status that? should you?
App start-up time? Lots of JS, slower start-up time.
Before you updated the entire page, now you update a piece of the page. What if the other data on the page is now stale?
Code-reuse, how do you do it, which part of stack?
What about JS failures or exceptions? Do you know about them, or only users are frustrated?
How do you use latest front-end techniques? Do you force users to upgrade their browsers?



Build an app SIG
-----------------
Initial app w/ bootstrap css
Mocked API, no actual back-end
Child grid - showing mock data
Chore grid - not working

First meeting goal - get project from GitHub, talk about it, talk about goal when we finish, get chore grid rendering using JQuery or plain DOM using data from mocked API.

Later meetings
  Dialog to add/edit/delete child
  Dialog to add chore, mark chore complete
  Connect to actual back-end, talk about latency issues with back-end
  Add validation
  Move dialogs to view and talk about routing, single page app
  Add grid sorting/filtering
  Use grid library? Use date picker library?













































Front-end & Back-end coupling
-----------------------------

Original Web App - Every action (click) goes back to the server, processed on server and new entire HTML page is returned. Users computer is a thin client.
"Modern" web app - Javascript required, some/most of the heavy lifting is done client-side. Users computer is a thick client.

Architectures

  SPA - single page app
     all HTML/JS/CSS for all pages is sent on first request to server, everything after that, only data is sent bw/ client&server using javascript
	 think gmail, google docs, google maps

  There are mixes of these
  Per screen - just HTML/JS/CSS relevant to screen of app you are interacting with is sent down. data is sent bw/ client&server using javascript.
  
  Important differences
     - what happens to send initial page load down to client from server?
	      - render html, including js/css tags
		  - talk to db to put data into returned page?
		      Original Web - yes always, your back-end is "probably" coupled to your front-end.
			  "Modern" App - probably not, no talking to db to get data.
			    Once JS is executing in the front-end, it makes AJAX requests to your back-end to get data from db.
				Now, your front-end is not as coupled to your back-end.
				Similiar to iOS/Android/Networked Desktop App - data isn't baked into the app, only UI and code for UI.
				Once app starts executing it makes requests over the network/filesystem to get data and then renders said data into the UI.
				
	PROS & CONS
	-----------
	- Original Web app
	    client can be anything, no JS required, it only needs to understand HTML/CSS. Search Engine, screen reader can parse this, also low powered devices (e.g. thin clients).
		for your code (e.g. business logic, validation) you control the execution environment, it's your server.
		your code is executing in a hostile environment, unknown hardware & unknown support of javascript with the user's ability to read/modify/copy your javascript.
		
	- Modern Web app
	    client has a powerful device, computer, laptop, tablet, smart phone, let's use it.
		more places to fail, search engine may not understand, screen reader may not understand, javascript might throw run-time exceptions and app fails on users browser, but you aren't aware of it.
		can send only data back and forth - can improve performance instead of data and surrounding markup (HTML) and styling (CSS).
		architecture is similiar to other apps (iOS/Android) - so can write back-end API once and re-use it between web app, iOS, Android app, or re-use back-end when you re-write front-end in a few years.
		the user can see the page, scroll it, navigate to another page quicker, because they aren't waiting on db calls to complete before they get any HTML back from the server.
		
	Can still mix these concepts for performance reasons, internationalization reasons, wider platform support, one is NOT better than another in all cases.
	Can this delegation between client/server be decided dynamically? Sure
	  This is isomorphic javascript or universal javascript, run javascript both on the server and in the browser.
	  You can then dynamically decide what executes where, e.g. fetch data from the db.
	
Can you still have coupling bw/ front-end/back-end even in a modern web app? Sure
  Just technology coupling, everything is in MVC project, so upgrading assemblies, .NET version affects front-end and back-end.
  Models - shared models to represent data in UI and data that is sent to/from back-end
  Validation - have server-side validation generate client-side JS that does validation.
  Is this coupling good/bad?
    Good, if you are only ever going to have one client for your back-end (e.g. web app) you can ensure things like model/validation are only expressed once and re-used everywhere.
	Bad, you are making it hard to update one without the other, potentially even in minor ways.
	This can be pronounced when you want to update the front-end (likely a few years down the road) but don't want to update your back-end which is now re-usable.
	
Can you use ensure front-end & back-end completely decoupled? Yes
  They only have to agree on a HTTP API interface.
  You can use .NET for back-end API and static HTML served from nodejs for front-end.
  Or you can simply create separate .NET projects for each.
  They should be hosted on the same domain though to avoid cross-domain restrictions, just because they are on the same domain doesn't mean they have to be on the same physical/virtual server.
  You can ensure this separation by building a mocked back-end (a fake implementation of your API).
  You may have to duplicate everything though, models, validation, etc and ensure they stay in sync with each other.
    You can go the hyper-media route (e.g. the back-end is completely self describing, it describes it models, their fields, their relationships and potentially their validations, in which base the front-end can dynamically parse this information)

Can you go too far with javascript? Maybe/Maybe not
  You have a common page layout, e.g.
    <div class="form-group">
	  <label for="FirstName">First Name: </label>
	  <div>
	    <input class="input-ctrl" type="text" id="FirstName" name="FirstName" />
		<div class="error-msg hidden"></div> 
	  </div>
	</div>
	
	You don't want to copy/paste that 50+ times in your application because when you decide to change something about that pattern, you have to update 50+ instances in your app and ideally test all updated instances.
	You want to create a common widget/helper for that. If you are using a heavy client-side framework (e.g. Angular, Ember, Aurelia) you solve this code re-use problem using javascript that gets executed in the users browser.
	So, now to display a form with 10 inputs, you have to execute your widget's JS 10 times in the users browser and the user has to wait until that JS is done before they can interact with your form.
	Maybe that's good, maybe it's bad. But you have a server-side framework, you could do that work on the server and the send the results to the browser such that no extra JS needs to be executed to solve your code re-use issue.

  The app loading spinner or mysterious flash or pause because you can't scroll.
    In some heavy client-side frameworks (Angular, Aurelia) nothing in the page is rendered until the framework has bootstrapped and then starts executing your JS which then renders your associated views/templates.
	Those frameworks have some methods to mitigate this effect, only binding those frameworks to portions of the page or other techniques.
	You can also opt to fix this with JS frameworks that provide both client and server-side rendering options (Meteor, React, Ember with Fast Boot).
	Or you can opt for developing your app in a progressive load scenario with frameworks that support this (Knockout, JQuery).
	Get your initial page to display with JS disabled with only required interaction working, e.g. maybe just navigation.
	Advanced interaction is progressively enabled as JS executes in your application.
	In an app that isn't progressive, all the page start JS has to finish executing before the user can use the page.
	In a progressive app, as pieces of the page start JS finishes executing those parts of the page are turned on and can interacted with.

Normal concerns amplified
-------------------------
Concurrency/Data storage
  No longer required to touch db on every click
  Client-side can assume back-end calls succeeded, update UI, and only deal with errors when they happen.
  For low concurrency scenarios, e.g. favorite one of my posts, no need to pull latest data from db, assume browser has the latest
  Detecting concurrency problems and prevent overwrites or perform automatic merges
  Ignore concurrency problems and last write wins
  During updates, server can use web sockets to push updates to all connected interested clients (e.g. chat)
  Updates can now happen without clicks (auto save every X minutes/seconds)
  What happens when the ajax fails because user login timed-out? Does user see that message?
  Can store data other places than the server, e.g. HTML5 local storage
    store in local storage, talk to server later
	only ever store in local storage, e.g. user preferences, always keep this tab open
	cache things in local storage
  Application can be made to work offline, service workers